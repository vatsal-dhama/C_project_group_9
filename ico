#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#pragma pack(1)
struct bmp_header {
    char identify[2];
    unsigned int size;
    int reserved;
    unsigned int image_offset;
};

struct dib_header {
    unsigned int dib_size;
    signed int width;
    signed int height;
    unsigned short int colour_planes;
    unsigned short int bits_per_pixel;
    unsigned int compression;
    unsigned int image_size;
    unsigned int res[4];


};

struct RGB {
    unsigned char blue;
    unsigned char green;
    unsigned char red;

};

struct ImageData {
    int height;
    int width;
    struct RGB **rgb;
};

struct ImageData read_image(FILE *fp, int height, int width) {
    struct ImageData picture;
    picture.rgb = (struct RGB**) malloc(height * sizeof(void*));
    picture.height = height;
    picture.width = width;

    for (int i = picture.height - 1; i >= 0; i--) {
        picture.rgb[i] = (struct RGB*) malloc(width * sizeof(struct RGB));
        fread(picture.rgb[i], sizeof(struct RGB), width, fp);
    }
    return picture;
}

void freeImage(struct ImageData picture) {
    for (int i = picture.height - 1; i >= 0; i--) {
        free(picture.rgb[i]);
    }
    free(picture.rgb);
}

void read_bmp() {
    FILE *fp;
    fp = fopen("input.bmp", "rb");

    struct bmp_header bmpheader;
    struct dib_header dibheader;

    fread(bmpheader.identify, 2, 1, fp);
    fread(&bmpheader.size, 12, 1, fp);

    //printf("First 2 chars: %c%c\n", bmpheader.identify[0], bmpheader.identify[1]);
    //printf("Size: %d\n", bmpheader.size);
    //printf("Offset: %d\n",bmpheader.image_offset);
    
    fread(&dibheader, sizeof(struct dib_header), 1, fp);
    
    //printf("Header Size: %d\nWidth: %d\nHeight: %d\nColour Planes: %d\nBits Per Pixel: %d\nCompression: %d\nImage Size: %d\n",dibheader.dib_size, dibheader.width, dibheader.height, dibheader.colour_planes, dibheader.bits_per_pixel, dibheader.compression, dibheader.image_size);
    
    fseek(fp, bmpheader.image_offset, SEEK_SET);

    struct ImageData picture = read_image(fp, dibheader.height, dibheader.width);
    fclose(fp);
    freeImage(picture);
}

struct ICONDIR
{
    short int reserved;
    short int image_specification;
    short int num_images;
};
struct ICONDIRENTRY
{
    short int image_width;  
    short int image_height; 
    short int num_colors;   //255
    short int reserve;
    short int color_planes;
    short int bits_per_pixel;
    int image_size;
    int image_offset;
};
struct BitmapInfoHeader
{
    unsigned int header_size; //sizeof(TBitmapInfoHeader)
    unsigned int width;       //width of bitmap
    unsigned int height;      //height of bitmap[biHeight field is set to 2 * ICONDIRENTRY.image_height]
    unsigned short int colourpanels; //1
    unsigned short int bitsperpixel; //24
    unsigned int compresion;         //0
    unsigned int imagesize;          //(ICONDIRENTRY.image_width * ICONDIRENTRY.image_height * 24) / 8 +
    unsigned int temp[4];            //(ICONDIRENTRY.image_width * ICONDIRENTRY.image_height) / 8
    
};
struct icoRGB {
    unsigned char blue;
    unsigned char green;
    unsigned char red;
    unsigned char reserved; //reserved, 0

};
void writeico(struct ICONDIR IconHeader, struct ICONDIRENTRY IconDirEntry, struct BitmapInfoHeader BitmapInfoHeader) {
    FILE *fpw;
    fpw = fopen("output.bmp", "wb");

    fwrite(bmpheader.identify, 2, 1, fpw);

    fwrite(&bmpheader.size, 12, 1, fpw);

    fwrite(&dibheader, sizeof(struct dib_header), 1, fpw);

    for (int i = picture.height - 1; i >= 0; i--) {
        fwrite(picture.rgb[i], sizeof(struct RGB), picture.width, fpw);
    }
    fclose(fpw);
}

int main() {
    read_bmp();
    write_ico();
}
